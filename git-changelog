#!/usr/bin/env bash
# This script was generated by bashly (https://github.com/DannyBen/bashly)
# Modifying it manually is not recommended

# :command.root_command
root_command() {
  # :src/root_command.sh
  limit="${args[--tail]}"
  color="${args[--color]}"
  reverse="${args[--reverse]}"
  out="${args[--out]}"
  save="${args[--save]}"
  tail_one="${args[-1]}"
  
  if [[ -n "$save" ]]; then
    out="CHANGELOG.md"
    reverse=1
  fi
  
  if [[ -n "$tail_one" ]]; then
    limit=1
  fi
  
  if [[ -n "$out" ]]; then
    get_markdown "$limit" "off" "$reverse" > "$out"
  else
    get_markdown "$limit" "$color" "$reverse"
  fi
}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
git_changelog_usage() {
  if [[ -n $long_usage ]]; then
    printf "git-changelog - Generate a human-readable change log from a git repo\n"
    echo 
  else
    printf "git-changelog - Generate a human-readable change log from a git repo\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  git-changelog [options]\n"
  printf "  git-changelog --help | -h\n"
  printf "  git-changelog --version | -v\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --tail, -t N"
    printf "    Show only the last N tags\n"
    echo
    
    # :flag.usage
    echo "  --reverse, -r"
    printf "    Show tags in reverse order (newest first)\n"
    echo
    
    # :flag.usage
    echo "  --out, -o PATH"
    printf "    Save output to a file\n"
    echo
    
    # :flag.usage
    echo "  --color, -c MODE"
    printf "    Enable or disable color. Supported modes:\n    - yes, on, always\n    - no, off, never\n    - auto\n"
    printf "    Default: auto\n"
    echo
    
    # :flag.usage
    echo "  --save, -s"
    printf "    Shortcut for '--reverse --out CHANGELOG.md'\n"
    echo
    
    # :flag.usage
    echo "  -1"
    printf "    Shortcut for '--tail 1'\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  git changelog --tail 3\n"
    printf "  git changelog --out CHANGELOG.md\n"
    printf "  git changelog -r -o CHANGELOG.md\n"
    echo

  fi
}

# :command.inspect_args
inspect_args() {
  echo args:
  for k in "${!args[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
}

# :command.user_lib
# :src/lib/abort.sh
abort() {
  red "$1"
  exit 1
}

# :src/lib/colors.sh
# ---
# Color functions
# This file is a part of Bashly standard library
#
# Usage:
# Use any of the functions below to color or format a portion of a string.
# 
#   echo "before $(red this is red) after"
#   echo "before $(green_bold this is green_bold) after"
#
# ---

red() { printf "\e[31m%b\e[0m\n" "$*"; }
green() { printf "\e[32m%b\e[0m\n" "$*"; }
yellow() { printf "\e[33m%b\e[0m\n" "$*"; }
blue() { printf "\e[34m%b\e[0m\n" "$*"; }
magenta() { printf "\e[35m%b\e[0m\n" "$*"; }
cyan() { printf "\e[36m%b\e[0m\n" "$*"; }
bold() { printf "\e[1m%b\e[0m\n" "$*"; }
underlined() { printf "\e[4m%b\e[0m\n" "$*"; }
red_bold() { printf "\e[1;31m%b\e[0m\n" "$*"; }
green_bold() { printf "\e[1;32m%b\e[0m\n" "$*"; }
yellow_bold() { printf "\e[1;33m%b\e[0m\n" "$*"; }
blue_bold() { printf "\e[1;34m%b\e[0m\n" "$*"; }
magenta_bold() { printf "\e[1;35m%b\e[0m\n" "$*"; }
cyan_bold() { printf "\e[1;36m%b\e[0m\n" "$*"; }
red_underlined() { printf "\e[4;31m%b\e[0m\n" "$*"; }
green_underlined() { printf "\e[4;32m%b\e[0m\n" "$*"; }
yellow_underlined() { printf "\e[4;33m%b\e[0m\n" "$*"; }
blue_underlined() { printf "\e[4;34m%b\e[0m\n" "$*"; }
magenta_underlined() { printf "\e[4;35m%b\e[0m\n" "$*"; }
cyan_underlined() { printf "\e[4;36m%b\e[0m\n" "$*"; }

# :src/lib/debug.sh
debug() {
  echo "DEBUG: $*" >&2
}

# :src/lib/get_latest_tag.sh
get_latest_tag() {
  git tag --sort=committerdate --format='%(refname:short)' | grep --color=never -P "^(v[[:digit:]]|[[:digit:]])" | tail -n 1
}

# :src/lib/get_log.sh
get_log() {
  ref="$1"

  set +e
  git log "$ref" --reverse --format='%s' | grep --color=never -P "^- "
  set -e
}

# :src/lib/get_markdown.sh
get_markdown() {
  limit=$1
  color=$2
  reverse=$3

  if [[ -z "$limit" ]]; then
    printf "Change Log\n"
    printf "========================================\n\n"
  fi

  refs=$(get_refs "$limit")

  [[ -n "$reverse" ]] && refs=$(reverse "${refs[@]}")
  [[ -n "$limit" ]] && refs=$(echo "$refs" | tail -n "$limit")

  for tag_data in $refs; do
    IFS=: read -ra data <<< "$tag_data" 
    tag=${data[0]}
    date=${data[1]}
    ref=${data[2]}

    commits=$(get_log "$ref")

    if [[ -n "$commits" ]]; then
      if use_color "$color" ; then
        printf "%s - %s\n" "$(green "$tag")" "$(cyan "$date")"
      else
        printf "%s - %s\n" "$tag" "$date"
      fi

      printf -- "----------------------------------------\n\n"
      printf "%s\n\n\n" "$commits"
    fi
  done
}

# :src/lib/get_refs.sh
# Returns an array, where each line is "tag:date:ref"
# It is the same as get tags, only with added ref
get_refs() {
  for tag_data in $(get_tags); do
    tag=${tag_data%:*}
    date=${tag_data#*:}

    if [[ -z "$last_tag" ]]; then
      ref="$tag"
    else
      ref="$last_tag..$tag"
    fi
    last_tag="$tag"
    printf "%s:%s\n" "$tag_data" "$ref"
  done

  if has_latest; then
    printf "Untagged:Latest:%s..HEAD" "$last_tag"
  fi
}

# :src/lib/get_sha.sh
get_sha() {
  ref="$1"
  result=$(git log "$ref" --reverse --format='%h:::%s' | grep --color=never -P ":::- " | tail -n 1)
  echo "${result%:*}"
}

# :src/lib/get_tags.sh
get_tags() {
  git tag --sort=committerdate --format='%(refname:short):%(committerdate:short)' | grep --color=never -P "^(v[[:digit:]]|[[:digit:]])"
}

# :src/lib/has_latest.sh
# Returns success if the repository has meaningful commits after the last tag
has_latest() {
  latest_tag=$(get_latest_tag)
  latest_tag_sha=$(get_sha "$latest_tag")
  head_sha=$(get_sha HEAD) 

  [[ "$latest_tag_sha" != "$head_sha" ]]
}

# :src/lib/is_tty.sh
is_tty() {
  [[ -t 1 || -p /dev/stdout ]]
}

# :src/lib/reverse.sh
# Reverse an array
# Usage: reverse "${your_array[@]}"
reverse() {
  arr=("$@")
  printf '%s\n' "${arr[@]}" | tac
}

# :src/lib/use_color.sh
use_color() {
  option=${1:-auto}

  if [[ "$option" == "yes" || "$option" == "on" || "$option" == "always" ]]; then
    return 0
  elif [[ "$option" == "no" || "$option" == "off" || "$option" == "never" ]]; then
    return 1
  else
    is_tty
  fi
}

# :src/lib/verify_git_repo.sh
verify_git_repo() {
  if ! git status &> /dev/null ; then
    abort "Not a git repository"
  fi

  if [[ -z $(get_tags) ]]; then
    abort "There are no usable tags in this repository"
  fi
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    git_changelog_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="root"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --tail | -t )
      if [[ $2 && $2 != -* ]]; then
        args[--tail]="$2"
        shift
        shift
      else
        printf "%s\n" "--tail requires an argument: --tail, -t N"
        exit 1
      fi
      ;;
  
    # :flag.case
    --reverse | -r )
      args[--reverse]=1
      shift
      ;;
  
    # :flag.case
    --out | -o )
      if [[ $2 && $2 != -* ]]; then
        args[--out]="$2"
        shift
        shift
      else
        printf "%s\n" "--out requires an argument: --out, -o PATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --color | -c )
      if [[ $2 && $2 != -* ]]; then
        args[--color]="$2"
        shift
        shift
      else
        printf "%s\n" "--color requires an argument: --color, -c MODE"
        exit 1
      fi
      ;;
  
    # :flag.case
    --save | -s )
      args[--save]=1
      shift
      ;;
  
    # :flag.case
    -1 )
      args[-1]=1
      shift
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.default_assignments
  [[ -n ${args[--color]} ]] || args[--color]="auto"
}

# :command.initialize
initialize() {
  version="0.1.9"
  long_usage=''
  set -e  

  # :src/initialize.sh
  verify_git_repo
}

# :command.run
run() {
  declare -A args
  parse_requirements "$@"

  if [[ ${args[--version]} ]]; then
    version_command
  elif [[ ${args[--help]} ]]; then
    long_usage=yes
    git-changelog_usage
  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"

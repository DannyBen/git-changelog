#!/usr/bin/env bash
# This script was generated by bashly 1.3.4 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script
# :command.root_command
root_command() {
  # src/root_command.sh
  verify_git_repo

  limit="${args[--tail]}"
  color="${args[--color]}"
  reverse="${args[--reverse]}"
  out="${args[--out]}"
  save="${args[--save]}"
  tail_one="${args[-1]}"
  tail_two="${args[-2]}"

  if [[ -n "$save" ]]; then
    out="CHANGELOG.md"
    reverse=1
  fi

  if [[ -n "$tail_one" ]]; then
    limit=1
  fi

  if [[ -n "$tail_two" ]]; then
    limit=2
  fi

  if [[ -n "$out" ]]; then
    save_markdown "$limit" "$reverse" "$out"
  else
    get_markdown "$limit" "$color" "$reverse"
  fi

}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
git_changelog_usage() {
  if [[ -n $long_usage ]]; then
    printf "git-changelog\n\n"
    printf "  Generate a human-readable changelog from git.\n  \n  This bash script lets you generate a human readable changelog from your git\n  repository.\n  \n  It requires that you:\n  \n  - Create git tags for the different versions of your code.\n  - Format the commit messages for commits you wish to include in the changelog,\n  in the same way you format a markdown bullet, by prefixing it with a hyphen\n  and a space (\"- \").\n\n"
  else
    printf "git-changelog - Generate a human-readable changelog from git.\n\n"
  fi

  printf "%s\n" "Usage:"
  printf "  git-changelog [OPTIONS]\n"
  printf "  git-changelog --help | -h\n"
  printf "  git-changelog --version | -v\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--tail, -t N"
    printf "    Show only the last N tags.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--reverse, -r"
    printf "    Show tags in reverse order (newest first).\n"
    echo

    # :flag.usage
    printf "  %s\n" "--out, -o PATH"
    printf "    Save output to a file.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--color, -c MODE"
    printf "    Enable or disable color. Supported modes:\n    \n    - \`yes\`, \`on\`, \`always\`\n    - \`no\`, \`off\`, \`never\`\n    - \`auto\`\n"
    printf "    %s\n" "Default: auto"
    echo

    # :flag.usage
    printf "  %s\n" "--save, -s"
    printf "    Shortcut for \`--reverse --out CHANGELOG.md\`.\n"
    echo

    # :flag.usage
    printf "  %s\n" "-1"
    printf "    Shortcut for \`--tail 1\`.\n"
    echo

    # :flag.usage
    printf "  %s\n" "-2"
    printf "    Shortcut for \`--tail 2\`.\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "CHANGELOG_COMMIT_URL"
    printf "    Set a URL template for commit links. This is passed to 'git log' as part of\n    the '--format' option, so you can use '%%h' or '%%H' to denote the commit\n    hash.\n    \n    Example: https://github.com/DannyBen/git-changelog/commit/%%h\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "CHANGELOG_COMPARE_URL"
    printf "    Set a URL template for comparing each tag with the previous tag. Use '%%s' in\n    your string to denote the ref range. When this is provided, an additional\n    bullet will be added to each block of changes with a comparison link.\n    \n    Example: https://github.com/dannyben/git-changelog/compare/%%s\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  git changelog --tail 3\n"
    printf "  git changelog --out CHANGELOG.md\n"
    printf "  git changelog -r -o CHANGELOG.md\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.user_lib
# src/lib/abort.sh
abort() {
  red "$1"
  exit 1
}

# src/lib/colors.sh
enable_auto_colors() {
  if [[ -z ${NO_COLOR+x} && ! -t 1 ]]; then
    NO_COLOR=1
  fi
}

print_in_color() {
  local color="$1"
  shift
  if [[ "${NO_COLOR:-}" == "" ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
black() { print_in_color "\e[30m" "$*"; }
white() { print_in_color "\e[37m" "$*"; }

bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }

red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
black_bold() { print_in_color "\e[1;30m" "$*"; }
white_bold() { print_in_color "\e[1;37m" "$*"; }

red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }
black_underlined() { print_in_color "\e[4;30m" "$*"; }
white_underlined() { print_in_color "\e[4;37m" "$*"; }

# src/lib/debug.sh
debug() {
  echo "DEBUG: $*" >&2
}

# src/lib/get_break_content.sh
get_break_content() {
  local filename="$1"
  local start_line

  start_line=$(grep -n "<!-- break .* -->" "$filename" | head -n1 | cut -d':' -f1)

  if [[ -n "$start_line" ]]; then
    sed -n "${start_line},\$p" "$filename"
  fi
}

# src/lib/get_break_marker.sh
get_break_marker() {
  local filename="$1"
  if [ -f "$filename" ]; then
    grep -oPm 1 '(?<=<!-- break )[^ ]+' "$filename" || echo ""
  else
    echo ""
  fi
}

# src/lib/get_latest_tag.sh
get_latest_tag() {
  git tag --sort=committerdate --format='%(refname:short)' | grep --color=never -P "^(v[[:digit:]]|[[:digit:]])" | tail -n 1
}

# src/lib/get_log.sh
get_log() {
  ref="$1"

  set +e
  if [[ -z $CHANGELOG_COMMIT_URL ]]; then
    git log "$ref" --reverse --format='%s' | grep --color=never -P "^- "
  else
    git log "$ref" --reverse --format="%s [\`%h\`]($CHANGELOG_COMMIT_URL)" | grep --color=never -P "^- "
  fi
  set -e
}

# src/lib/get_markdown.sh
get_markdown() {
  limit=$1
  color=$2
  reverse=$3
  break_before=$4

  if [[ -z "$limit" ]]; then
    printf "Changelog\n"
    printf "========================================\n\n"
  fi

  refs=$(get_refs "$limit")

  [[ -n "$reverse" ]] && refs=$(reverse "${refs[@]}")
  [[ -n "$limit" ]] && refs=$(echo "$refs" | tail -n "$limit")

  for tag_data in $refs; do
    IFS=: read -ra data <<<"$tag_data"

    tag=${data[0]}
    date=${data[1]}
    ref=${data[2]}

    if [[ -n "$break_before" && "$tag" == "$break_before" ]]; then
      break
    fi

    commits=$(get_log "$ref")
    [[ -n "$commits" ]] || continue

    if use_color "$color"; then
      printf "%s - %s\n" "$(green "$tag")" "$(cyan "$date")"
    else
      printf "%s - %s\n" "$tag" "$date"
    fi

    printf -- "----------------------------------------\n\n"

    if [[ -z $CHANGELOG_COMPARE_URL ]]; then
      printf "%s\n\n\n" "$commits"
    else
      # shellcheck disable=SC2059
      # Disabling SC2059 (quoted format string) because we use dynamic format strings
      compare_url=$(printf "$CHANGELOG_COMPARE_URL" "$ref")
      compare_link="Compare [\`$ref\`]($compare_url)"
      printf "%s\n- %s\n\n\n" "$commits" "$compare_link"
    fi
  done
}

# src/lib/get_refs.sh
# Returns an array, where each line is "tag:date:ref"
# It is the same as get tags, only with added ref
get_refs() {
  for tag_data in $(get_tags); do
    tag=${tag_data%:*}
    date=${tag_data#*:}

    if [[ -z "$last_tag" ]]; then
      ref="$tag"
    else
      ref="$last_tag..$tag"
    fi
    last_tag="$tag"
    printf "%s:%s\n" "$tag_data" "$ref"
  done

  if has_latest; then
    printf "Untagged:Latest:%s..HEAD" "$last_tag"
  fi
}

# src/lib/get_sha.sh
get_sha() {
  ref="$1"
  result=$(git log "$ref" --reverse --format='%h:::%s' | grep --color=never -P ":::- " | tail -n 1)
  echo "${result%:*}"
}

# src/lib/get_tags.sh
get_tags() {
  git tag --sort=committerdate --format='%(refname:short):%(committerdate:short)' | grep --color=never -P "^(v[[:digit:]]|[[:digit:]])"
}

# src/lib/has_latest.sh
# Returns success if the repository has meaningful commits after the last tag
has_latest() {
  latest_tag=$(get_latest_tag)
  latest_tag_sha=$(get_sha "$latest_tag")
  head_sha=$(get_sha HEAD)

  [[ "$latest_tag_sha" != "$head_sha" ]]
}

# src/lib/is_tty.sh
is_tty() {
  [[ -t 1 || -p /dev/stdout ]]
}

# src/lib/reverse.sh
# Reverse an array
# Usage: reverse "${your_array[@]}"
reverse() {
  arr=("$@")
  printf '%s\n' "${arr[@]}" | tac
}

# src/lib/save_markdown.sh
save_markdown() {
  limit=$1
  reverse=$2
  filename="$3"

  break_before=$(get_break_marker "$filename")

  if [[ -n "$break_before" ]]; then
    break_content=$(get_break_content "$filename")
    get_markdown "$limit" "off" "$reverse" "$break_before" >"$filename"
    echo "$break_content" >>"$filename"
  else
    get_markdown "$limit" "off" "$reverse" >"$filename"
  fi
}

# src/lib/use_color.sh
use_color() {
  option=${1:-auto}

  if [[ "$option" == "yes" || "$option" == "on" || "$option" == "always" ]]; then
    return 0
  elif [[ "$option" == "no" || "$option" == "off" || "$option" == "never" ]]; then
    return 1
  else
    is_tty
  fi
}

# src/lib/verify_git_repo.sh
verify_git_repo() {
  if ! git status &>/dev/null; then
    abort "Not a git repository"
  fi

  if [[ -z $(get_tags) ]]; then
    abort "There are no usable tags in this repository"
  fi
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        git_changelog_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v git >/dev/null 2>&1; then
    printf "missing dependency: git\n" >&2
    missing_deps=1
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action="root"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --tail | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tail']="$2"
          shift
          shift
        else
          printf "%s\n" "--tail requires an argument: --tail, -t N" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --reverse | -r)

        # :flag.case_no_arg
        args['--reverse']=1
        shift
        ;;

      # :flag.case
      --out | -o)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--out']="$2"
          shift
          shift
        else
          printf "%s\n" "--out requires an argument: --out, -o PATH" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --color | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--color']="$2"
          shift
          shift
        else
          printf "%s\n" "--color requires an argument: --color, -c MODE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --save | -s)

        # :flag.case_no_arg
        args['--save']=1
        shift
        ;;

      # :flag.case
      -1)

        # :flag.case_no_arg
        args['-1']=1
        shift
        ;;

      # :flag.case
      -2)

        # :flag.case_no_arg
        args['-2']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--color']:-} ]] || args['--color']="auto"

}

# :command.initialize
initialize() {
  declare -g version="0.3.3"
  set -e

  # src/initialize.sh

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "root") root_command ;;
  esac
}

# :command.start
command_line_args=("$@")
initialize
run "${command_line_args[@]}"

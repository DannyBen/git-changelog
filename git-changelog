#!/usr/bin/env bash
# This script was generated by bashly (https://github.com/DannyBen/bashly)
# Modifying it manually is not recommended

# :command.root_command
root_command() {
  # :src/root_command.sh
  limit="${args[--tail]}"
  color="${args[--color]:=auto}"
  out="${args[--out]}"
  
  if [[ -n "$out" ]]; then
    get_markdown "$limit" "off" > "$out"
  else
    get_markdown "$limit" "$color"
  fi
}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
git_changelog_usage() {
  if [[ -n $long_usage ]]; then
    printf "git-changelog - Generate a human-readable change log from a git repo\n"
    echo 
  else
    printf "git-changelog - Generate a human-readable change log from a git repo\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  git-changelog [options]\n"
  printf "  git-changelog --help | -h\n"
  printf "  git-changelog --version | -v\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --tail, -t N"
    printf "    Show only the last N tags\n"
    echo
    
    # :flag.usage
    echo "  --out, -o PATH"
    printf "    Save output to a file\n"
    echo
    
    # :flag.usage
    echo "  --color, -c OPTION"
    printf "    Enable or disable color. Supported options:\n    - yes, on, always\n    - no, off, never\n    - auto\n"
    printf "    Default: auto\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  git changelog --tail 3\n"
    printf "  git changelog --out CHANGELOG.md\n"
    echo

  fi
}

# :command.inspect_args
inspect_args() {
  echo args:
  for k in "${!args[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
}

# :command.user_lib
# :src/lib/colors.sh
# ---
# Color functions
# This file is a part of Bashly standard library
#
# Usage:
# Use any of the functions below to color or format a portion of a string.
# 
#   echo "before $(red this is red) after"
#   echo "before $(green_bold this is green_bold) after"
#
# ---

red() { printf "\e[31m%b\e[0m\n" "$*"; }
green() { printf "\e[32m%b\e[0m\n" "$*"; }
yellow() { printf "\e[33m%b\e[0m\n" "$*"; }
blue() { printf "\e[34m%b\e[0m\n" "$*"; }
magenta() { printf "\e[35m%b\e[0m\n" "$*"; }
cyan() { printf "\e[36m%b\e[0m\n" "$*"; }
bold() { printf "\e[1m%b\e[0m\n" "$*"; }
underlined() { printf "\e[4m%b\e[0m\n" "$*"; }
red_bold() { printf "\e[1;31m%b\e[0m\n" "$*"; }
green_bold() { printf "\e[1;32m%b\e[0m\n" "$*"; }
yellow_bold() { printf "\e[1;33m%b\e[0m\n" "$*"; }
blue_bold() { printf "\e[1;34m%b\e[0m\n" "$*"; }
magenta_bold() { printf "\e[1;35m%b\e[0m\n" "$*"; }
cyan_bold() { printf "\e[1;36m%b\e[0m\n" "$*"; }
red_underlined() { printf "\e[4;31m%b\e[0m\n" "$*"; }
green_underlined() { printf "\e[4;32m%b\e[0m\n" "$*"; }
yellow_underlined() { printf "\e[4;33m%b\e[0m\n" "$*"; }
blue_underlined() { printf "\e[4;34m%b\e[0m\n" "$*"; }
magenta_underlined() { printf "\e[4;35m%b\e[0m\n" "$*"; }
cyan_underlined() { printf "\e[4;36m%b\e[0m\n" "$*"; }

# :src/lib/get_log.sh
get_log() {
  from=$1
  to=${2:-HEAD}

  if [[ -n "$from" ]]; then
    ref="$from..$to"
  else
    ref="$to"
  fi

  set +e
  git log "$ref" --pretty=format:'%s' | grep --color=never -P "^- "
  set -e
}

# :src/lib/get_markdown.sh
get_markdown() {
  limit=$1
  color=$2
  skip_first="$limit"

  printf "Change Log\n"
  printf "========================================\n\n"

  for tag_data in $(get_tags "$limit"); do
    tag=${tag_data%:*}
    date=${tag_data#*:}

    if [[ -z "$last_tag" ]]; then
      from=''
      to=$tag
      last_tag=$tag
    else
      from=$last_tag
      to=$tag
      last_tag=$tag
    fi

    if [[ $skip_first ]]; then
      skip_first=''
      continue
    fi

    commits=$(get_log "$from" "$to")

    if [[ -n "$commits" ]]; then
      if use_color "$color" ; then
        printf "%s - %s\n" "$(green "$tag")" "$(cyan "$date")"
      else
        printf "%s - %s\n" "$tag" "$date"
      fi

      printf -- "----------------------------------------\n\n"
      printf "%s\n\n\n" "$commits"
    fi
  done

  commits=$(get_log "$last_tag" "HEAD")

  if [[ -n "$commits" ]]; then
    if use_color "$color" ; then
      printf "%s - %s\n" "$(green Untagged)" "$(cyan Latest)"
    else
      printf "Untagged - Latest\n"
    fi

    printf -- "----------------------------------------\n\n"
    printf "%s\n\n\n" "$commits"
  fi
}

# :src/lib/get_tags.sh
get_tags() {
  limit="$1"
  result=$(git tag --sort=v:creatordate --format='%(refname:short):%(creatordate:short)' | grep --color=never -P "^(v[[:digit:]]|[[:digit:]])")
  
  if [[ -z "$limit" ]]; then
    echo "$result"
  else
    limit=$(( "$limit" + 1 ))
    echo "$result" | tail -n "$limit"
  fi
}

# :src/lib/is_tty.sh
is_tty() {
  [[ -t 1 || -p /dev/stdout ]]
}

# :src/lib/use_color.sh
use_color() {
  option=${1:-auto}

  if [[ "$option" == "yes" || "$option" == "on" || "$option" == "always" ]]; then
    return 0
  elif [[ "$option" == "no" || "$option" == "off" || "$option" == "never" ]]; then
    return 1
  else
    is_tty
  fi
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    git_changelog_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="root"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --tail | -t )
      if [[ $2 && $2 != -* ]]; then
        args[--tail]="$2"
        shift
        shift
      else
        printf "%s\n" "--tail requires an argument: --tail, -t N"
        exit 1
      fi
      ;;
  
    # :flag.case
    --out | -o )
      if [[ $2 && $2 != -* ]]; then
        args[--out]="$2"
        shift
        shift
      else
        printf "%s\n" "--out requires an argument: --out, -o PATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --color | -c )
      if [[ $2 && $2 != -* ]]; then
        args[--color]="$2"
        shift
        shift
      else
        printf "%s\n" "--color requires an argument: --color, -c OPTION"
        exit 1
      fi
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.default_assignments
  [[ -n ${args[--color]} ]] || args[--color]="auto"
}

# :command.initialize
initialize() {
  version="0.1.2"
  long_usage=''
  set -e  

  # :src/initialize.sh
}

# :command.run
run() {
  declare -A args
  parse_requirements "$@"

  if [[ ${args[--version]} ]]; then
    version_command
  elif [[ ${args[--help]} ]]; then
    long_usage=yes
    git-changelog_usage
  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
